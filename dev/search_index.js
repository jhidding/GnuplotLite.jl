var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GnuplotLite]","category":"page"},{"location":"api/#GnuplotLite.Gnuplot","page":"API","title":"GnuplotLite.Gnuplot","text":" struct Gnuplot\n\nThis struct is not exported, as it is not supposed to be created by a user, other than through calling gnuplot(), or save().\n\nMessages can be sent to a Gnuplot instance using the send() method:\n\ngnuplot() do g\n    g |> send(\"plot sin(x)\")\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#GnuplotLite.Msg","page":"API","title":"GnuplotLite.Msg","text":" struct Msg\n\nThis wraps the actions that are created using the different variants of the send() method.\n\nMessages can be composed (unlike âˆ˜, going left to right) using the * operator.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.close-Tuple{GnuplotLite.Gnuplot}","page":"API","title":"Base.close","text":" close(::Gnuplot)\n\nClose the Gnuplot process by closing the underlying channel. The actual process my continue living if terminals are left open.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.gnuplot-Tuple{Function}","page":"API","title":"GnuplotLite.gnuplot","text":" gnuplot(::Function; kwargs...)\n\nVariant of the gnuplot constructor for use with do syntax. Makes sure to close the channel (and thereby) the process.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.gnuplot-Tuple{}","page":"API","title":"GnuplotLite.gnuplot","text":"gnuplot(persist = true, echo = false)\n\nThe main constructor for a Gnuplot instance. This starts the gnuplot process and creates a channel to which commands can be sent.\n\nThe persist argument make sure that any interactive window remains open, even if we have closed the pipe to the Gnuplot process.\n\nThe echo argument is for debugging. If enabled, all commands send to this instance are also echoed to stdout.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.save-Tuple{String}","page":"API","title":"GnuplotLite.save","text":" save(path::String)\n\nCreate a phony Gnuplot instance, without the underlying process attached. Instead, write messages to file. You can then later turn the file into a plot by running it with Gnuplot from the command line, or run a pipeline from Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.send-Tuple{String}","page":"API","title":"GnuplotLite.send","text":" send(::String)\n\nSend a literal message to a Gnuplot instance. This is supposed to be used using a pipe (|>) operator.\n\nReturns a Msg.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.send-Union{Tuple{Pair{String, Matrix{T}}}, Tuple{T}} where T<:Number","page":"API","title":"GnuplotLite.send","text":" send(::Pair{String,Matrix{T}}) where T <: Number\n\nSend a matrix to Gnuplot, storing it in a variable. This variant assumes the matrix gets integer indices from [0..N-1], as described in the Gnuplot documentation for uniform matrices.\n\nReturns a Msg.\n\n\n\n\n\n","category":"method"},{"location":"api/#GnuplotLite.send-Union{Tuple{Pair{String, NamedTuple{(:x, :y, :z), Tuple{T, T, U}}}}, Tuple{U}, Tuple{T}} where {T<:(AbstractVector{<:Real}), U<:(AbstractMatrix{<:Real})}","page":"API","title":"GnuplotLite.send","text":" send(::Pair{String,@NamedTuple{x::T,y::T,z::U}}) where\n    {T <: AbstractVector{<:Real}, U <: AbstractMatrix{<:Real}}\n\nSend a matrix to Gnuplot, storing it in a variable. This variant also sends axis information along with the matrix, as described in the Gnuplot documentation for nonuniform matrices.\n\nReturns a Msg.\n\nExample:\n\n    x = y = -1:0.1:1\n    z = x.^2 .- y'.^2\n    gnuplot() do gp\n        gp |> \n            send(\"data\" => (x=collect(x), y=collect(y), z=z)) |>\n            send(\"splot $data w l\")\n    end\n\n\n\n\n\n","category":"method"},{"location":"#Introduction-to-GnuplotLite.jl","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"","category":"section"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"This module is a Julia wrapper for Gnuplot. This has the following design goals:","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Responsiveness: this should be the thinnest of possible wrappers. The biggest drag to plotting in Julia is the number of lines of code that sit in between the programmer and the plotter.\nComposability: it should be easy to extend GnuplotLite.\nTransparency: it should be easy to reason about how data is entered into Gnuplot.","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"That being said, there are so many plotting packages in Julia. When should you use this?","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Use GnuplotLite if you are in love with Gnuplot and want nothing to sit in between you and it.","category":"page"},{"location":"#Alternatives","page":"Introduction to GnuplotLite.jl","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Plotting in Julia is a notoriously hard problem. Why? A core issue with many plotting packages in Julia is that these packages become too big, and then compiling all the necessary code makes things slow. So the problem is a combination of the one-shot nature of plotting and the complexity of the packages involved.","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"A related problem with plotting packages in any language, is that two problems get conflated: data analysis and visualization. This makes for very nice interfaces a la GGPlot (which I find brilliant), however, on the implementation side this needlessly complicates things. The focus on visualizing data-frames has left it very hard to work with grid based data in most modern packages (plotly, ggplot, vegalite, bokeh, you name it).","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Plots.jl is a large package that provides a uniform interface over a lot of backends. I have recently tried Plots with the most recommended backends: GR, Plotly, Pyplot, Gaston. The GR backend worked really well, but it was really hard to tweak the output towards publication quality. In other words, plotting was relatively fast but hideous to the limit of being buggy. All the other backends that I tried gave me installation issues.\nGadfly.jl looks very promising, but is very slow to respond with larger data sets.\nGnuplot.jl is a thin wrapper around Gnuplot. My problem with this package is that it focusses heavily on use with a macro @gp. Because of this, code in Gnuplot.jl suffers from a lack of composability. It is also not so straight forward to see exactly how @gp code translates to gnuplot commands when arrays are used.\nGaston.jl is a slightly thicker wrapper around Gnuplot, mirroring Gnuplot syntax in Julia functions. I could not make it work.","category":"page"},{"location":"#Tutorial","page":"Introduction to GnuplotLite.jl","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Start a Gnuplot session by running gnuplot(). Then send it messages using |> send(...).","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"using GnuplotLite\n\ng = gnuplot()\ng |> send(\"plot sin(x)\")\nclose(g)","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Note that using gnuplot() this way may leave the actual Gnuplot process dangling. There is do-notation to prevent that:","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"gnuplot() do g\n    g |> send(\"plot sin(x)\")\nend","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"Messages can be composed:","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"using GnuplotLite\n\nsetup(output) = \n    send(\"set term svg background 'white' size 600,400 dynamic \" *\n         \"mouse standalone\") *\n    send(\"set output '$output'\")\n\ngnuplot() do g\n    g |> setup(\"sine.svg\") |> send(\"plot sin(x)\")\nend","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"(Image: )","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"You may enter data into Gnuplot by sending a pair of string and x y z data. This gets translated into an inline data definition.","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"settings = \"\"\"\nset pm3d lighting primary 0.5 specular 0.3\nset pm3d depthorder border lc 'black' lw 0.3\nset style fill solid 1.00 noborder\nset ticslevel 0\nset autoscale fix\nset tmargin 0\nunset colorbox\n\"\"\"\n\nx = -4:0.15:4\ny = x\nz = sinc.(sqrt.(x.^2 .+ y'.^2))\n\nplot = setup(\"sinc3d.svg\") *\n    send(settings) *\n    send(\"set title 'radial sinc function'\") *\n    send(\"data\" => (x=x, y=y, z=z)) *\n    send(\"splot \\$data nonuniform matrix \" *\n         \"using 1:2:3:(0xffad00) t'' \" *\n         \"with pm3d lc rgb variable\")\n\ngnuplot() |> plot |> close","category":"page"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"(Image: )","category":"page"},{"location":"#Under-the-hood","page":"Introduction to GnuplotLite.jl","title":"Under the hood","text":"","category":"section"},{"location":"","page":"Introduction to GnuplotLite.jl","title":"Introduction to GnuplotLite.jl","text":"There are two objects in GnuplotLite: the Gnuplot instance and Msg. The Gnuplot instance contains a channel to which you can send Gnuplot commands. A Msg contains a function of type ::Gnuplot -> ::Gnuplot that then actually sends the commands to the channel. By abstracting the messages into a function we can stay efficient while being fully composable. Because of the composability we can easily extend GnuplotLite to interact with data the way you want.","category":"page"}]
}
